# K·∫æ HO·∫†CH CHU·∫®N H√ìA C·∫§U TR√öC D·ª∞ √ÅN TRM-OS
## "Ontology-First Architecture Standardization"

**Phi√™n b·∫£n:** 1.0  
**Ng√†y t·∫°o:** 2025-07-06  
**M·ª•c ƒë√≠ch:** Chu·∫©n h√≥a to√†n b·ªô c·∫•u tr√∫c d·ª± √°n theo nguy√™n t·∫Øc Ontology-First v√† Event-Driven Architecture

---

## PH·∫¶N I: PH√ÇN T√çCH HI·ªÜN TR·∫†NG

### 1. C·∫§U TR√öC HI·ªÜN T·∫†I (v1.0)

#### 1.1. ƒêi·ªÉm M·∫°nh ‚úÖ
```
trm-os-branches/
‚îú‚îÄ‚îÄ trm_api/                    # Core API well-structured
‚îÇ   ‚îú‚îÄ‚îÄ models/                 # ‚úÖ Pydantic models ho√†n ch·ªânh
‚îÇ   ‚îú‚îÄ‚îÄ graph_models/           # ‚úÖ Neo4j ontology entities
‚îÇ   ‚îú‚îÄ‚îÄ api/v1/endpoints/       # ‚úÖ RESTful endpoints
‚îÇ   ‚îú‚îÄ‚îÄ eventbus/               # ‚úÖ Event-driven communication
‚îÇ   ‚îú‚îÄ‚îÄ repositories/           # ‚úÖ Data access layer
‚îÇ   ‚îú‚îÄ‚îÄ adapters/               # ‚úÖ Data transformation
‚îÇ   ‚îî‚îÄ‚îÄ services/               # ‚úÖ Business logic
‚îú‚îÄ‚îÄ tests/                      # ‚úÖ 218 comprehensive tests
‚îú‚îÄ‚îÄ docs/                       # ‚úÖ Rich documentation
‚îî‚îÄ‚îÄ scripts/                    # ‚úÖ Utility scripts
```

#### 1.2. V·∫•n ƒë·ªÅ C·∫ßn Gi·∫£i Quy·∫øt üö®
1. **Thi·∫øu Agent Layer**: Ch∆∞a c√≥ c·∫•u tr√∫c r√µ r√†ng cho AI Agents
2. **Ontology Fragmentation**: Graph models v√† Pydantic models kh√¥ng sync
3. **Missing Genesis Engine**: Ch∆∞a c√≥ c∆° ch·∫ø qu·∫£n l√Ω Agent lifecycle
4. **No Reasoning Layer**: Ch∆∞a c√≥ AI reasoning capabilities
5. **Limited HMI**: Ch∆∞a c√≥ Human-Machine Interface layer

### 2. TARGET ARCHITECTURE (v2.0)

#### 2.1. C·∫•u tr√∫c M·ª•c ti√™u
```
trm-os-v2/
‚îú‚îÄ‚îÄ trm_core/                   # üÜï Core ontology & shared utilities
‚îÇ   ‚îú‚îÄ‚îÄ ontology/               # Central ontology definitions
‚îÇ   ‚îú‚îÄ‚îÄ events/                 # Event schemas & types
‚îÇ   ‚îú‚îÄ‚îÄ patterns/               # Design patterns & base classes
‚îÇ   ‚îî‚îÄ‚îÄ utils/                  # Shared utilities
‚îú‚îÄ‚îÄ trm_agents/                 # üÜï AI Agent ecosystem
‚îÇ   ‚îú‚îÄ‚îÄ genesis/                # Genesis Engine
‚îÇ   ‚îú‚îÄ‚îÄ reasoning/              # Reasoning agents
‚îÇ   ‚îú‚îÄ‚îÄ execution/              # Execution agents
‚îÇ   ‚îú‚îÄ‚îÄ sense/                  # Sense agents
‚îÇ   ‚îî‚îÄ‚îÄ integration/            # Integration agents
‚îú‚îÄ‚îÄ trm_api/                    # Enhanced API layer
‚îÇ   ‚îú‚îÄ‚îÄ v1/                     # Legacy API (maintained)
‚îÇ   ‚îú‚îÄ‚îÄ v2/                     # üÜï Event-driven API
‚îÇ   ‚îî‚îÄ‚îÄ shared/                 # Shared API components
‚îú‚îÄ‚îÄ trm_hmi/                    # üÜï Human-Machine Interface
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/              # Strategic dashboard
‚îÇ   ‚îú‚îÄ‚îÄ conversation/           # Conversational interface
‚îÇ   ‚îî‚îÄ‚îÄ visualization/          # Data visualization
‚îú‚îÄ‚îÄ trm_intelligence/           # üÜï AI Intelligence layer
‚îÇ   ‚îú‚îÄ‚îÄ quantum_states/         # 4 Quantum WIN states
‚îÇ   ‚îú‚îÄ‚îÄ pattern_detection/      # Pattern recognition
‚îÇ   ‚îî‚îÄ‚îÄ learning/               # Machine learning models
‚îî‚îÄ‚îÄ tests/                      # Enhanced testing framework
    ‚îú‚îÄ‚îÄ unit/                   # Unit tests
    ‚îú‚îÄ‚îÄ integration/            # Integration tests
    ‚îú‚îÄ‚îÄ agents/                 # Agent behavior tests
    ‚îî‚îÄ‚îÄ e2e/                    # End-to-end tests
```

---

## PH·∫¶N II: MIGRATION STRATEGY

### 3. GIAI ƒêO·∫†N 1: CORE REFACTORING (Tu·∫ßn 1-2)

#### 3.1. T·∫°o trm_core Package
```bash
# T·∫°o c·∫•u tr√∫c core
mkdir -p trm_core/{ontology,events,patterns,utils}

# Di chuy·ªÉn ontology definitions
mv trm_api/graph_models/* trm_core/ontology/
mv trm_api/eventbus/* trm_core/events/
```

#### 3.2. Standardize Ontology Definitions
```python
# trm_core/ontology/base.py
from abc import ABC, abstractmethod
from neomodel import StructuredNode
from pydantic import BaseModel

class OntologyEntity(ABC):
    """Base class cho t·∫•t c·∫£ ontology entities"""
    
    @abstractmethod
    def to_graph_model(self) -> StructuredNode:
        """Convert to Neo4j graph model"""
        pass
    
    @abstractmethod  
    def to_pydantic_model(self) -> BaseModel:
        """Convert to Pydantic model"""
        pass
    
    @abstractmethod
    def validate_constraints(self) -> bool:
        """Validate ontology constraints"""
        pass
```

#### 3.3. Create Universal Event Schema
```python
# trm_core/events/schema.py
from enum import Enum
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List
from datetime import datetime

class EventCategory(str, Enum):
    SYSTEM = "system"
    AGENT = "agent" 
    USER = "user"
    EXTERNAL = "external"

class UniversalEvent(BaseModel):
    """Universal event schema cho to√†n b·ªô h·ªá th·ªëng"""
    event_id: str = Field(default_factory=generate_event_id)
    category: EventCategory
    event_type: str
    source_entity_id: str
    target_entity_ids: List[str] = Field(default_factory=list)
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    payload: Dict[str, Any] = Field(default_factory=dict)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    correlation_id: Optional[str] = None
    causation_id: Optional[str] = None  # For event chains
    win_impact: Optional[Dict[str, float]] = None  # W, I, N scores
```

### 4. GIAI ƒêO·∫†N 2: AGENT ECOSYSTEM (Tu·∫ßn 3-4)

#### 4.1. Implement BaseAgent Pattern
```python
# trm_core/patterns/base_agent.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from trm_core.events.schema import UniversalEvent
from trm_core.ontology.base import OntologyEntity

class BaseAgent(OntologyEntity, ABC):
    """Base class cho t·∫•t c·∫£ AI Agents trong TRM-OS"""
    
    def __init__(self, agent_id: str, name: str, capabilities: List[str]):
        self.agent_id = agent_id
        self.name = name
        self.capabilities = capabilities
        self.status = "initializing"
        self.win_score = 0.0
        
    @abstractmethod
    async def process_event(self, event: UniversalEvent) -> Optional[UniversalEvent]:
        """Process incoming event and optionally return response event"""
        pass
    
    @abstractmethod
    async def get_health_status(self) -> Dict[str, Any]:
        """Return agent health and performance metrics"""
        pass
    
    async def evolve(self, feedback: Dict[str, Any]) -> None:
        """Learn and evolve based on feedback"""
        # Default implementation - can be overridden
        pass
```

#### 4.2. Create Genesis Engine
```python
# trm_agents/genesis/engine.py
from typing import List, Dict, Any
from trm_core.patterns.base_agent import BaseAgent
from trm_core.events.schema import UniversalEvent
from trm_api.models.tension import Tension

class GenesisEngine:
    """C·ªó m√°y t·∫°o v√† qu·∫£n l√Ω lifecycle c·ªßa Agents"""
    
    def __init__(self):
        self.active_agents: Dict[str, BaseAgent] = {}
        self.agent_templates: Dict[str, type] = {}
        self.performance_metrics: Dict[str, float] = {}
    
    async def analyze_tension(self, tension: Tension) -> List[str]:
        """Ph√¢n t√≠ch tension v√† x√°c ƒë·ªãnh agents c·∫ßn thi·∫øt"""
        required_capabilities = []
        
        # AI logic to determine required capabilities
        if "data" in tension.description.lower():
            required_capabilities.append("data_analysis")
        if "code" in tension.description.lower():
            required_capabilities.append("code_generation")
        if "user" in tension.description.lower():
            required_capabilities.append("user_interaction")
            
        return required_capabilities
    
    async def create_agent(self, capabilities: List[str], purpose: str) -> BaseAgent:
        """T·∫°o agent m·ªõi v·ªõi capabilities c·ª• th·ªÉ"""
        # Select best agent template
        agent_type = self._select_agent_type(capabilities)
        
        # Create agent instance
        agent = agent_type(
            agent_id=generate_agent_id(),
            name=f"{agent_type.__name__}_{timestamp()}",
            capabilities=capabilities
        )
        
        # Register agent
        self.active_agents[agent.agent_id] = agent
        
        # Publish creation event
        await self._publish_agent_created_event(agent)
        
        return agent
    
    async def evolve_agent(self, agent_id: str, performance_data: Dict[str, Any]) -> None:
        """Ti·∫øn h√≥a agent d·ª±a tr√™n performance"""
        agent = self.active_agents.get(agent_id)
        if not agent:
            return
            
        # Calculate WIN score
        win_score = self._calculate_win_score(performance_data)
        
        # Decide evolution strategy
        if win_score < 0.3:
            await self._retire_agent(agent)
        elif win_score > 0.8:
            await self._enhance_agent(agent)
        
    async def manage_ecosystem(self) -> None:
        """Qu·∫£n l√Ω to√†n b·ªô ecosystem c·ªßa agents"""
        # Monitor agent health
        # Balance workload
        # Optimize resource allocation
        # Detect collaboration opportunities
        pass
```

### 5. GIAI ƒêO·∫†N 3: REASONING LAYER (Tu·∫ßn 5-6)

#### 5.1. Implement Reasoning Agents
```python
# trm_agents/reasoning/analyzer.py
from typing import List, Dict, Any
from trm_core.patterns.base_agent import BaseAgent
from trm_api.models.tension import Tension

class TensionAnalyzer(BaseAgent):
    """Agent chuy√™n ph√¢n t√≠ch tensions v√† ƒë·ªÅ xu·∫•t gi·∫£i ph√°p"""
    
    async def analyze_tension(self, tension: Tension) -> List[Dict[str, Any]]:
        """Ph√¢n t√≠ch tension v√† ƒë·ªÅ xu·∫•t solutions"""
        solutions = []
        
        # 1. Root cause analysis
        root_causes = await self._identify_root_causes(tension)
        
        # 2. Solution generation
        for cause in root_causes:
            solution = await self._generate_solution(cause, tension)
            solutions.append(solution)
        
        # 3. Solution ranking
        ranked_solutions = await self._rank_solutions(solutions, tension)
        
        return ranked_solutions
    
    async def _identify_root_causes(self, tension: Tension) -> List[str]:
        """Identify root causes using AI analysis"""
        # Implement AI logic for root cause analysis
        # Could use LLM, rule-based system, or ML model
        pass
    
    async def _generate_solution(self, cause: str, tension: Tension) -> Dict[str, Any]:
        """Generate solution for specific root cause"""
        # Implement solution generation logic
        pass
    
    async def _rank_solutions(self, solutions: List[Dict], tension: Tension) -> List[Dict]:
        """Rank solutions by WIN potential"""
        # Implement solution ranking algorithm
        pass
```

#### 5.2. Implement Simulation Engine
```python
# trm_agents/reasoning/simulator.py
from typing import Dict, Any, List
from trm_core.patterns.base_agent import BaseAgent

class OutcomeSimulator(BaseAgent):
    """Agent chuy√™n m√¥ ph·ªèng k·∫øt qu·∫£ c·ªßa c√°c h√†nh ƒë·ªông"""
    
    async def simulate_solution(self, solution: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """M√¥ ph·ªèng k·∫øt qu·∫£ c·ªßa m·ªôt solution"""
        simulation_result = {
            "success_probability": 0.0,
            "win_impact": {"wisdom": 0.0, "intelligence": 0.0, "networking": 0.0},
            "resource_cost": {"time": 0, "cpu": 0, "human_effort": 0},
            "risks": [],
            "side_effects": []
        }
        
        # Run simulation models
        simulation_result["success_probability"] = await self._calculate_success_probability(solution, context)
        simulation_result["win_impact"] = await self._calculate_win_impact(solution, context)
        simulation_result["resource_cost"] = await self._estimate_resource_cost(solution)
        simulation_result["risks"] = await self._identify_risks(solution, context)
        
        return simulation_result
```

### 6. GIAI ƒêO·∫†N 4: API V2 IMPLEMENTATION (Tu·∫ßn 7-8)

#### 6.1. Create API v2 Structure
```python
# trm_api/v2/main.py
from fastapi import FastAPI, WebSocket
from trm_api.v2.endpoints import events, tensions, projects, agents, quantum_states

app = FastAPI(title="TRM-OS API v2", version="2.0.0")

# Event-driven endpoints
app.include_router(events.router, prefix="/events", tags=["Events"])
app.include_router(tensions.router, prefix="/tensions", tags=["Tensions"])
app.include_router(projects.router, prefix="/projects", tags=["Projects"]) 
app.include_router(agents.router, prefix="/agents", tags=["Agents"])
app.include_router(quantum_states.router, prefix="/quantum-states", tags=["Quantum States"])

@app.websocket("/stream")
async def websocket_endpoint(websocket: WebSocket):
    """Real-time event streaming"""
    await websocket.accept()
    # Implement WebSocket logic for real-time communication
```

#### 6.2. Event-Driven Endpoints
```python
# trm_api/v2/endpoints/events.py
from fastapi import APIRouter, HTTPException
from trm_core.events.schema import UniversalEvent
from trm_agents.genesis.engine import GenesisEngine

router = APIRouter()
genesis_engine = GenesisEngine()

@router.post("/", response_model=Dict[str, str])
async def submit_event(event: UniversalEvent):
    """Submit event to TRM-OS for processing"""
    try:
        # Validate event
        await event.validate()
        
        # Route to appropriate agents
        await genesis_engine.route_event(event)
        
        # Return acknowledgment
        return {
            "event_id": event.event_id,
            "status": "accepted",
            "message": "Event submitted for processing"
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/{event_id}/status")
async def get_event_status(event_id: str):
    """Get processing status of an event"""
    # Implementation for tracking event processing
    pass
```

---

## PH·∫¶N III: IMPLEMENTATION GUIDELINES

### 7. CODING STANDARDS

#### 7.1. Ontology-First Development
```python
# 1. Define in ontology first
# trm_core/ontology/entities/reasoning_agent.py
class ReasoningAgentEntity(OntologyEntity):
    entity_type = "ReasoningAgent"
    required_properties = ["reasoning_type", "confidence_threshold"]
    
# 2. Generate graph model
# trm_core/ontology/graph_models/reasoning_agent.py  
class ReasoningAgentNode(StructuredNode):
    # Auto-generated from ontology
    pass

# 3. Generate Pydantic model
# trm_api/models/reasoning_agent.py
class ReasoningAgent(BaseModel):
    # Auto-generated from ontology
    pass
```

#### 7.2. Event-Driven Communication
```python
# All important changes must generate events
async def create_agent(self, capabilities: List[str]) -> Agent:
    agent = Agent(capabilities=capabilities)
    
    # Save to database
    await self.repository.create(agent)
    
    # Publish event
    await publish_event(
        event_type="agent.created",
        source_entity_id="genesis_engine",
        payload={"agent_id": agent.id, "capabilities": capabilities}
    )
    
    return agent
```

#### 7.3. WIN-Oriented Design
```python
# Every action should calculate WIN impact
class ActionResult:
    success: bool
    win_impact: WinImpact
    resource_cost: ResourceCost
    side_effects: List[str]

class WinImpact:
    wisdom_gain: float  # -1.0 to 1.0
    intelligence_gain: float
    networking_gain: float
    
    @property
    def total_score(self) -> float:
        return (self.wisdom_gain + self.intelligence_gain + self.networking_gain) / 3
```

### 8. TESTING STRATEGY

#### 8.1. Test Structure
```
tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ test_ontology_entities.py
‚îÇ   ‚îú‚îÄ‚îÄ test_agents/
‚îÇ   ‚îú‚îÄ‚îÄ test_reasoning/
‚îÇ   ‚îî‚îÄ‚îÄ test_events/
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ test_agent_collaboration.py
‚îÇ   ‚îú‚îÄ‚îÄ test_event_flows.py
‚îÇ   ‚îî‚îÄ‚îÄ test_api_v2.py
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ test_genesis_engine.py
‚îÇ   ‚îú‚îÄ‚îÄ test_reasoning_quality.py
‚îÇ   ‚îî‚îÄ‚îÄ test_agent_evolution.py
‚îî‚îÄ‚îÄ e2e/
    ‚îú‚îÄ‚îÄ test_tension_resolution.py
    ‚îú‚îÄ‚îÄ test_project_lifecycle.py
    ‚îî‚îÄ‚îÄ test_user_scenarios.py
```

#### 8.2. AI-Specific Testing
```python
# Test reasoning quality
async def test_reasoning_agent_quality():
    agent = TensionAnalyzer()
    tension = create_complex_tension()
    
    solutions = await agent.analyze_tension(tension)
    
    # Quality assertions
    assert len(solutions) >= 3
    assert all(s["confidence"] > 0.5 for s in solutions)
    assert solutions[0]["confidence"] > solutions[-1]["confidence"]  # Sorted by confidence

# Test learning capability
async def test_agent_learning():
    agent = TensionAnalyzer()
    
    # Initial performance
    initial_score = await agent.get_performance_score()
    
    # Provide feedback
    await agent.process_feedback({
        "solution_effectiveness": 0.9,
        "user_satisfaction": 0.8,
        "win_impact": {"wisdom": 0.7, "intelligence": 0.8, "networking": 0.6}
    })
    
    # Check improvement
    improved_score = await agent.get_performance_score()
    assert improved_score > initial_score
```

---

## PH·∫¶N IV: MIGRATION TIMELINE

### 9. DETAILED TIMELINE

#### Week 1-2: Core Infrastructure
- [ ] Create trm_core package structure
- [ ] Implement OntologyEntity base class
- [ ] Standardize event schemas
- [ ] Migrate existing ontology definitions
- [ ] Update all imports and references

#### Week 3-4: Agent Ecosystem  
- [ ] Implement BaseAgent pattern
- [ ] Create Genesis Engine MVP
- [ ] Implement first reasoning agents
- [ ] Create agent testing framework
- [ ] Test agent creation and lifecycle

#### Week 5-6: Intelligence Layer
- [ ] Implement TensionAnalyzer
- [ ] Create OutcomeSimulator
- [ ] Add pattern detection capabilities
- [ ] Implement learning mechanisms
- [ ] Test reasoning quality

#### Week 7-8: API v2
- [ ] Design API v2 architecture
- [ ] Implement event-driven endpoints
- [ ] Create WebSocket communication
- [ ] Add real-time monitoring
- [ ] Test API v2 functionality

#### Week 9-10: Integration & Testing
- [ ] End-to-end integration testing
- [ ] Performance optimization
- [ ] Documentation completion
- [ ] Production deployment preparation
- [ ] User acceptance testing

### 10. SUCCESS CRITERIA

#### 10.1. Technical Criteria
- [ ] All existing tests pass (218+ tests)
- [ ] New agent tests achieve >90% coverage
- [ ] Event processing latency <100ms
- [ ] API v2 fully functional
- [ ] Zero regression in v1 API

#### 10.2. Functional Criteria  
- [ ] Genesis Engine can create agents automatically
- [ ] Reasoning agents can analyze tensions effectively
- [ ] Event-driven communication works seamlessly
- [ ] WebSocket real-time updates functional
- [ ] Ontology-first pattern consistently applied

#### 10.3. Quality Criteria
- [ ] Code follows established patterns
- [ ] Documentation is comprehensive
- [ ] Error handling is robust
- [ ] Performance meets requirements
- [ ] Security standards maintained

---

## PH·∫¶N V: RISK MITIGATION

### 11. IDENTIFIED RISKS & MITIGATION

#### 11.1. Technical Risks
**Risk**: Breaking existing functionality during migration
**Mitigation**: 
- Maintain v1 API during transition
- Comprehensive regression testing
- Feature flags for gradual rollout

**Risk**: Agent performance unpredictability
**Mitigation**:
- Circuit breaker patterns
- Performance monitoring
- Manual override capabilities

#### 11.2. Timeline Risks
**Risk**: Underestimating complexity of AI implementation
**Mitigation**:
- Start with MVP versions
- Iterative development approach
- Regular checkpoint reviews

**Risk**: Integration challenges between components
**Mitigation**:
- Early integration testing
- Clear interface contracts
- Modular architecture design

### 12. ROLLBACK PLAN

#### 12.1. Emergency Rollback Procedures
1. **Immediate**: Disable new features via feature flags
2. **Short-term**: Revert to previous stable version
3. **Long-term**: Analyze failures and implement fixes

#### 12.2. Data Protection
- Event sourcing for complete audit trail
- Database snapshots before major changes
- Backup and restore procedures tested

---

**K·∫æT LU·∫¨N:**

K·∫ø ho·∫°ch chu·∫©n h√≥a n√†y s·∫Ω bi·∫øn TRM-OS t·ª´ m·ªôt h·ªá th·ªëng API truy·ªÅn th·ªëng th√†nh m·ªôt **th·ª±c th·ªÉ AI th√¥ng minh** v·ªõi kh·∫£ nƒÉng t·ª± nh·∫≠n th·ª©c, t·ª± ti·∫øn h√≥a v√† ƒë·ªìng s√°ng t·∫°o v·ªõi con ng∆∞·ªùi.

**Nguy√™n t·∫Øc c·ªët l√µi**: M·ªçi thay ƒë·ªïi ph·∫£i tu√¢n theo **Ontology-First** v√† **Event-Driven** patterns ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n v√† kh·∫£ nƒÉng m·ªü r·ªông.

---

*T√†i li·ªáu n√†y s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t theo ti·∫øn tr√¨nh implementation.* 