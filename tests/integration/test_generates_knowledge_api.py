import pytest
import pytest_asyncio
from unittest.mock import patch
from unittest.mock import AsyncMock
import uuid
from datetime import datetime
from httpx import AsyncClient
from fastapi import status

from trm_api.main import app
from trm_api.models.relationships import Relationship
from trm_api.services.relationship_service import RelationshipService
from tests.conftest import get_test_client


class TestGeneratesKnowledgeAPI:
    """Integration tests for the GENERATES_KNOWLEDGE relationship API endpoints."""
    
    async def setup_method(self):
        """Set up test fixtures before each test method."""
        # Sample IDs for testing
        self.win_id = str(uuid.uuid4())
        self.snippet_id = str(uuid.uuid4())
        
        # Sample relationship data
        self.sample_relationship = {
            "source_id": self.win_id,
            "source_type": "Win",
            "target_id": self.snippet_id,
            "target_type": "KnowledgeSnippet",
            "type": "GENERATES_KNOWLEDGE",
            "createdAt": datetime.utcnow().isoformat()
        }
        
        # Set up async client
        self.client = await get_test_client()
    
    @pytest.mark.asyncio
    @patch.object(RelationshipService, 'create_relationship')
    async def test_create_generates_knowledge_relationship(self, mock_create_relationship):
        """Test creating a GENERATES_KNOWLEDGE relationship via API."""
        # Setup mock as AsyncMock
        mock_create_relationship.return_value = Relationship(**self.sample_relationship)
        mock_create_relationship.side_effect = AsyncMock(return_value=Relationship(**self.sample_relationship))
        
        # Execute test with async client
        response = await self.client.post(
            "/api/v1/relationships/generates-knowledge",
            params={
                "win_id": self.win_id,
                "knowledge_id": self.snippet_id
            }
        )
        
        # Assertions
        assert response.status_code == status.HTTP_201_CREATED
        data = response.json()
        assert data["source_id"] == self.win_id
        assert data["source_type"] == "Win"
        assert data["target_id"] == self.snippet_id
        assert data["target_type"] == "KnowledgeSnippet"
        assert data["type"] == "GENERATES_KNOWLEDGE"
        
        # Verify mock was called correctly
        mock_create_relationship.assert_called_once_with(
            source_id=self.win_id,
            source_type="Win",
            target_id=self.snippet_id,
            target_type="KnowledgeSnippet",
            relationship_type="GENERATES_KNOWLEDGE"
        )
    
    @pytest.mark.asyncio
    @patch.object(RelationshipService, 'create_relationship')
    async def test_create_generates_knowledge_relationship_not_found(self, mock_create_relationship):
        """Test creating a GENERATES_KNOWLEDGE relationship with non-existent entities."""
        # Setup mock
        mock_create_relationship.return_value = None
        mock_create_relationship.side_effect = AsyncMock(return_value=None)
        
        # Execute test with async client
        response = await self.client.post(
            "/api/v1/relationships/generates-knowledge",
            params={
                "win_id": self.win_id,
                "knowledge_id": self.snippet_id
            }
        )
        
        # Assertions
        assert response.status_code == status.HTTP_404_NOT_FOUND
        data = response.json()
        assert "detail" in data
        
        # Verify mock was called correctly
        mock_create_relationship.assert_called_once()
    
    @pytest.mark.asyncio
    @patch.object(RelationshipService, 'get_relationships')
    async def test_get_knowledge_snippets_by_win(self, mock_get_relationships):
        """Test getting knowledge snippets generated by a WIN."""
        # Setup mock
        mock_relationship = Relationship(**self.sample_relationship)
        mock_get_relationships.side_effect = AsyncMock(return_value=[mock_relationship])
        mock_get_relationships.return_value = [mock_relationship]
        
        # Execute test with async client
        response = await self.client.get(f"/api/v1/relationships/wins/{self.win_id}/generates-knowledge")
        
        # Assertions
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert isinstance(data, list)
        assert len(data) == 1
        assert data[0]["source_id"] == self.win_id
        assert data[0]["target_id"] == self.snippet_id
        assert data[0]["type"] == "GENERATES_KNOWLEDGE"
        
        # Verify mock was called correctly
        mock_get_relationships.assert_called_once_with(
            entity_id=self.win_id,
            entity_type="Win",
            direction="outgoing",
            relationship_type="GENERATES_KNOWLEDGE",
            related_entity_type="KnowledgeSnippet"
        )
    
    @pytest.mark.asyncio
    @patch.object(RelationshipService, 'get_relationships')
    async def test_get_wins_by_knowledge_snippet(self, mock_get_relationships):
        """Test getting WINs that generate a specific knowledge snippet."""
        # Setup mock
        mock_relationship = Relationship(**self.sample_relationship)
        mock_get_relationships.return_value = [mock_relationship]
        mock_get_relationships.side_effect = AsyncMock(return_value=[mock_relationship])
        
        # Execute test with async client
        response = await self.client.get(f"/api/v1/relationships/knowledge-snippets/{self.snippet_id}/generated-from-wins")
        
        # Assertions
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert isinstance(data, list)
        assert len(data) == 1
        assert data[0]["source_id"] == self.win_id
        assert data[0]["target_id"] == self.snippet_id
        assert data[0]["type"] == "GENERATES_KNOWLEDGE"
        
        # Verify mock was called correctly
        mock_get_relationships.assert_called_once_with(
            entity_id=self.snippet_id,
            entity_type="KnowledgeSnippet",
            direction="incoming",
            relationship_type="GENERATES_KNOWLEDGE",
            related_entity_type="Win"
        )
    
    @patch.object(RelationshipService, 'delete_relationship')
    def test_delete_generates_knowledge_relationship(self, mock_delete_relationship):
        """Test deleting a GENERATES_KNOWLEDGE relationship."""
        # Setup mock
        mock_delete_relationship.return_value = True
        
        # Execute test
        response = client.delete(
            "/api/v1/relationships/generates-knowledge",
            params={
                "win_id": self.win_id,
                "knowledge_id": self.snippet_id
            }
        )
        
        # Assertions
        assert response.status_code == status.HTTP_204_NO_CONTENT
        
        # Verify mock was called correctly
        mock_delete_relationship.assert_called_once_with(
            source_id=self.win_id,
            source_type="Win",
            target_id=self.snippet_id,
            target_type="KnowledgeSnippet",
            relationship_type="GENERATES_KNOWLEDGE"
        )
    
    @patch.object(RelationshipService, 'delete_relationship')
    def test_delete_generates_knowledge_relationship_not_found(self, mock_delete_relationship):
        """Test deleting a non-existent GENERATES_KNOWLEDGE relationship."""
        # Setup mock
        mock_delete_relationship.return_value = False
        
        # Execute test
        response = client.delete(
            "/api/v1/relationships/generates-knowledge",
            params={
                "win_id": self.win_id,
                "knowledge_id": self.snippet_id
            }
        )
        
        # Assertions
        assert response.status_code == status.HTTP_404_NOT_FOUND
        data = response.json()
        assert "detail" in data
        
        # Verify mock was called correctly
        mock_delete_relationship.assert_called_once()
